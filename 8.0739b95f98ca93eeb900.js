(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{FLcJ:function(e,n,t){"use strict";t.r(n);var o=t("CcnG"),a=function(){return function(){}}(),i=t("pMnS"),s=t("gKl1"),r=t("vs+N"),l=t("BJNQ"),c=t("ZYCi"),d=t("3xi6"),p=function(){return function(){this.mdFile=t("eVzs")}}(),u=o.ob({encapsulation:2,styles:[],data:{}});function h(e){return o.Eb(0,[(e()(),o.qb(0,0,null,null,1,"app-markdown",[],null,null,null,s.b,s.a)),o.pb(1,4308992,null,0,r.a,[o.k,l.a,c.l,d.a],{mdFile:[0,"mdFile"]},null)],function(e,n){e(n,1,0,n.component.mdFile)},null)}function m(e){return o.Eb(0,[(e()(),o.qb(0,0,null,null,1,"app-oss-rules",[],null,null,null,h,u)),o.pb(1,49152,null,0,p,[],null,null)],null,null)}var g=o.mb("app-oss-rules",p,m,{},{},[]),f=t("Ip0R"),b=function(){return function(){}}(),y=t("n6bp");t.d(n,"OssRulesModuleNgFactory",function(){return v});var v=o.nb(a,[],function(e){return o.wb([o.xb(512,o.j,o.cb,[[8,[i.a,g]],[3,o.j],o.x]),o.xb(4608,f.k,f.j,[o.u,[2,f.r]]),o.xb(1073742336,f.b,f.b,[]),o.xb(1073742336,c.o,c.o,[[2,c.u],[2,c.l]]),o.xb(1073742336,b,b,[]),o.xb(1073742336,y.a,y.a,[]),o.xb(1073742336,a,a,[]),o.xb(1024,c.j,function(){return[[{path:"",component:p}]]},[])])})},eVzs:function(e,n){e.exports='# OSS Rules and MetaUI Application\n\nIn this section we will extend our application from the [getting started guide][1] where a simple \npage was generated and also cover more advanced aspect behind but before we get into how to use OSS, \nlets start with a [quick overview of the syntax][6] and its similarities and differences to other \nsyntaxes you may know already. \n\n\n\n* [Overview of the OSS syntax][6]\n* [Extend MetaUI Applications](#extend-metaui-applications)\n* [Rules](#rules)\n* [Context and Properties](#context-and-properties)\n* [Chaining](#chaining)\n* [Built-in Rules](#built-in-rules)\n* [Application Rules](#application-rules)\n* [Rule Loading](#rule-loading)\n* [Rule Ranking](#rule-ranking)\n* [Visibility](#visibility)\n* [Validation](#validation)\n* [Editibility](#editibility)\n* [Actions](#actions) \n* [Layouts](#layouts)\n* [Other Areas to Explore](#other-areas-to-explore)\n\n\n#### Extend MetaUI Applications\n\nLet\'s add two more fields on the `User.ts` object from the getting started guide:\n\n```ts\n\nconstructor(public uniqueName?: string, public name?: string,\n              public description?: string, public created?: Date,\n              public age?: number, public isAngularDeveloper: boolean = false) {\n  }\n\n\n```\n\nWe want to keep it relatively simple so we added fields `age` and `isAngularDeveloper`. Let\'s also add type definition so \nrules can properly introspect these fields.\n\n\n```ts\n\n  getTypes(): any {\n    return {\n      uniqueName: String,\n      name: Number,\n      description: String,\n      created: Date,\n      age: Number,\n      isAngularDeveloper: Boolean\n    };\n```\n\nand extend our rule file `app/rules/User.oss` which tells the framework how and where these new fields \nshould be rendered. Let\'s show these field in `create` operation and default one which is `view`\n\n```ts\n\n  class=User {\n  \n        field=uniqueName {\n             label:"Id"\n        }\n  \n         field=name {\n             label:"Name"\n         }\n  \n         field=description {\n             trait:longtext;\n         }\n  \n         zNone => *;\n         zLeft => uniqueName => name => description => created => age => isAngularDeveloper;\n  }\n  \n  /*\n    Sample definition for operations edit and create\n  \n  */\n  class= User {\n     operation=(edit, create) {\n        zNone => *;\n        zLeft => name => description;\n     }\n  \n    operation=(create) {\n        zNone => *;\n        zLeft => name => description => created => isAngularDeveloper;\n     }\n  \n  }\n```\n\nand also extend a component constructor where we instantiate `User`\n```typescript\n\n this.object = new User(\'R0001\', \'Frank Kolar\', \'This is my user record\', new Date(),  20, true);\n\n```\n \n\nlet\'s recompile and look at the application again\n\n```ts\n  npm run compile:oss\n  ng serve \n\n```\nYou can also run `npm run watch:oss` that monitors any `oss` changes and recompile automatically.\n\n\n### Rules\n\nHere we are getting to the first topic the **Rules**. As you can see to add additional two fields we did not do much. \nYou extend only the domain object `User` and update a rule file just like you do with your css.\n\nA _Rule_ defines a map of properties that should apply in the event that a set of Selectors are matched. \nGiven a rule base Meta and a set of asserted values Context a list of matching rules can be computed \n(by matching their selectors against the values) and by successively (in rank / priority order) \napplying (merging) their property maps, a set of effective properties can be computed. \n\n\nEach rule can be stated like this:\n\n```ts\nIf selectors [__,__,...] match the current context values,\nthen apply the properties [__,__,...].\n```\n\nThese rules can come from a variety of sources:\n\n* **Runtime introspection of Typescript classes**\n    \n    These rules declare the available properties (fields)  along with their data types. \n    \n    _Example: "What are the fields in the `User` class?" In rules term:_\n    \n\n```ts\n  If selectors [class=User, declare=field]\n      match the current context values,\n  then apply the properties\n      [field:name]\n  \n  \n  If selectors [class=User, declare=field]\n      match the current context values,\n  then apply the properties\n      [field:isAngularDeveloper]\n            \n  ...    \n```    \n\n  Since typescript (javascript) does not offer proper reflection support so we can introspect a class \n  the `getTypes()` method exists.\n\n\n* **Built-in rules**\n\n  MetaUI includes a base set of rules (`WidgetsRuels.oss`) to describe, for instance, a mapping from field \n  data type to UI component. Example: "If it\'s a Boolean (`isAngularDeveloper`) and we\'re editing, use \n  the Checkbox component." \n  \n  In rules term:\n  \n\n```ts\n  If selectors [field=any, type=Boolean, editable=true]\n      match the current context values,\n  then apply the properties\n      [component:CheckboxComponent]\n```  \n\n\n* **Application provided rules**\n\n  Applications may provide explicit rules via "object style sheet (oss) files" (`User.oss`). These are a convenient \n  place to express presentation-oriented rules that really don\'t belong in (UI agnostic) domain classes. \n \n  \n  Example: "The description field should appear after name field." In rules term:\n  \n```ts\n  If selectors [class=User, field=description]\n      match the current context values,\n  then apply the properties\n      [after:name]\n```  \n\nIn our example you could see OSS syntax in form of (description goes after name):\n\n```ts\nzLeft => uniqueName => name => description => created => age => isAngularDeveloper;\n```\n\nor can be expressed as:\n\n```ts\nclass=User {\n     field=description {\n         after: name;\n     }\n```\n\n* **Other Sources of Meta Data**\n\n  Many applications have other external sources of information about the application\'s \n  domain classes. For instance, an application may have meta data comming from Rest API \n  that provide additional information about classes and fields that should be taken into account\n  when creating user interfaces (e.g. "is this field an owned to-many relationship?"). MetaUI provides generic \n  hooks for integrating such sources of metadata (in fact, the metadata sources above \n  integrate via these same hooks).\n      \n  \nWe\'ll go into more details for each type of rules, but for now let\'s take a look at context and properties...\n\n   \n   \n### Context and Properties\n\nContext represents a stack of assignments (e.g. [object]="user", operation="create", layout="Inspect"). \nThe current values are run against the Meta rule set to compute the effective property map.\nThe property map holds property key/value pairs that directly affects the UI (eg, component="CheckboxComponent", editable="false")\n\nThis is similar to how CSS works. HTML elements can have classes to provide context. For example:\n\n```html\n\n  <div class="box">\n      <h1>Hey</h1>\n  </div>\n  \n  <div class="X">\n   <div class="box">\n      <h1>There</h1>\n   </div>\n  </div>\n```\nThen you have rules that depending on the context and how they are nested, you get different styling properties:\n\n```css\n\n  .box {\n     border:1px solid red;\n     width:100px;\n     float:left;\n     color:green;\n  }\n  /*\n     if an element with class "box" that is contained\n     in an element with class "X",\n     then applies these properties\n  */\n  .X .box {\n      border:3px solid blue;\n      background-color:yellow;\n  }\n  /*\n     if a h1 element is contained\n     in an element with class "box" that is contained\n     in an element with class "X",\n     then applies these properties\n  */\n  .X .box h1 {\n      color:orange;\n  }\n```\n\n\nIf multiples rules match, properties are merged and overridden. In this example,the "There" element \nmerged the width and float properties, but overrode the border and color properties from more specific rules.\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/css-rule.png "CSS Rule Example")\n\n\nIn MetaUI, context values are set using `MetaContextComponent`:\n\n```html\n  <m-context [object]="user" operation="create" layout="Inspect">\n      <m-include-component></m-include-component>\n  </m-context>\n\n\n  <m-context [object]="user" operation="view" layout="Inspect">\n        <m-include-component></m-include-component>\n  </m-context>\n```\n\nThen you have rules that depending on the context and how they are nested, you get different UI properties:\n\n```ts\n  If selectors [operation=create, field=any]\n      match the current context values,\n  then apply the properties\n      [editing:true]\n  \n  If selectors [operation=view, field=any]\n      match the current context values,\n  then apply the properties\n      [editing:false]\n\n```\n\n`MetaIncludeComponent` and various Meta components takes the effective property map to generate \nprogramatically the UI.\n\n<img width="600" height="385" title="Create operation" src="https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/meta-create.png" >\n\n\nand view operation: \n\n\n<img width="400" height="305" title="view operation" src="https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/meta-view.png" >\n\n\n\n##### Here are some interesting context keys:\n\n* **module**: Global nav tab\n* **layout**: Define a named layout (e.g. "Inspect", "SearchForm")\n* **operation**: "view", "edit", "create", "search", "list"\n* **class**:  Class name\n* **object**: Object instance (e.g. a User object)\n* **action**: An action (e.g. could be fired from a button)\n* **field**: Current field of class\n* **elementType**: If type is collection, the type of its elements\n* **editing**: Currently editing? Derived from operation\n* **trait**: Current traits in effect (like CSS classes)\n\n##### Here are some interesting property keys:\n\n###### General\n\n* **trait**: List of traits to apply\n* **after**: Name of item (or zone) that this item should follow (for layout order)\n* **visible**: Should current item be shown\n* **component**: Component name to use for display\n* **bindings**: Map of bindings to pass to component\n* **wrapperComponent**: Name of component to wrap around this component (also, wrapperBindings)\n\n\n###### Class\n\n* **fieldsByZone**: Map of List<Fields> for the layout zones (e.g. "zTop", "zLeft", \x85)\n* **zonePath**: Zone key path for sub map to render\n* **zNone**: Special zone which makes field invisible\n* **zLeft**: Specific named zone that renders fields in the Left zone (the same applies for other zones: zRight, zBottom, zMiddle, zTop)\n\n\n###### Layout, Module, Field, Action\n\n* **label**: Display key \n \n###### Field\n\n* **editable**: Should current field be editable\n* **valid**: Is current value valid\n\n\n###### Layout\n\n* **layoutsByZone**: List of sub-layout names grouped by zone (zTop, zLeft, \x85)\n\n\n###### Action\n\n* **actionResults**: Executes js code that can fire any action\n\n\n\nHere are some of the interesting context keys that are explicitly set into the context:\n\n* **field**: set by MetaFormTableComponent\n* **action**: set by MetaActionListComponent\n* **actionCategory**: set by MetaActionListComponent\n* **class**: set by MetaFormTableComponent\n* **object**: set by MetaFormTableComponent\n* **layout**: set by MetaFormTableComponent MetaSectionComponent, MetaDashboardLayoutComponent\n* **module**: set by MetaHomePage\n\n\nHowever, some are implicitly set by the MetaUI engine. It\'s time to talk about chaining...\n\n\n### Chaining\n\nChaining is when some properties resulting from one rule are fed back as new context assignments, \nresulting in new matches.\n\nThese context assignments are "implied" by the current assignments are applied, (resulting in a revised \ncomputation of the current property map, and possible further chaining).\n\nReferring to the rules listed below, we can see how this particular chaining sequence happens:\n\n* The `field=isAngularDeveloper` value is assigned into the context by MetaFormTableComponent and activates rules 1 - 5.\n* The `type` property from rule 1 is chained/implicitly assigned backed into the context and activates rules 4 and 5.\n* The `editing` property from 2 is chained/implicitly assigned backed into the context and activates rule 3.\n* The `editable` property from 3 is chained/implicitly assigned backed into the context and activates rule 4.\n\n\n```ts\n1) If selectors [class=User, field=isAngularDeveloper]\n       match the current context values,\n   then apply the properties\n       [type:Boolean]\n\n\n2) If selectors [operation=create, field=any]\n       match the current context values,\n    then apply the properties\n        [editing:true]\n\n\n3) If selectors [field=any,editing=true]\n       match the current context values,\n   then apply the properties\n       [editable:true]\n\n\n4) If selectors [field=any, type=Boolean, editable=any]\n       match the current context values,\n   then apply the properties\n       [component:CheckboxComponent]\n\n\n5) If selectors [field=any, type=Boolean]\n       match the current context values,\n   then apply the properties\n       [bindings: {value=value}]\n\n```\n\nNot all properties are chained. The following are some of the interesting properties that are chained:\n\n* class\n* type\n* elementType\n* trait\n* editable\n* editing\n* layout\n* component\n\nYou should now have a sense of the power of rule based UI. Most of the rules to generate the UI are \nalready available from the domain object, or are conventions that are redundant to repeat. We don\'t need \nto worry about updating all the areas every time we add/remove/change a field.\n\n**Let\'s extend our example**\n\nLet\'s add proper label _"Full name"_ for `name` field like this in the `User.oss`:\n\n```ts\nclass=User {\n\n  field=name {\n     label:"Full name"\n  }\n  ...\n```\n\n\n```\nNote: Don\'t forget to run "npm run compile:oss" when you modify OSS rule file unless you launched in the other \nterminal "npm run watch:oss" command\n```\n\n\n\nWe just defined new selectors for [class=className, field=fieldName]. So in our example, this rule was created:\n\n```ts\nIf selectors [class=User, field=name]\n    match the current context values,\nthen apply the properties\n    [label:"Full name"]\n```\n\n\n\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/full-name.png "Updated label")\n\n\n\nWe can similarly add `trait` properties like this:\n\n```ts\nclass=User {\n\n  field=name {\n     label:"Full name";\n     trait:required;\n  }    \n  field=description {     \n       trait:longtext;\n  }  \n  ...\n```\n\n\nThe following rule is created:\n\n```ts\n  If selectors [class=User, field=name]\n      match the current context values,\n  then apply the properties\n      [trait:required]\n      \n  If selectors [class=User, field=description]\n      match the current context values,\n  then apply the properties\n      [trait:longtext]    \n\n```\n\nNow the _name_ field is required and description changed from simple text text field to text area.\n\n\n<p width="10px">\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/trait-longtext.png "Trait required")\n\n</p>\nWe\'ve discussed how `MetaIncludeComponent` switches in the right component with the \ncomponent property through chaining. As mentioned, the trait property is chained \nback to the context, but where are the rest of rules involved? This takes us to \nthe MetaUI built-in rules.\n\n\n\n### Built-in Rules\n\nAn important source of built-in rules are specified in `WidgetsRules.oss`. In this file, \nyou will find many useful rules for data type, decoration, trait, operation, layout, action, \nand module in OSS. In particular, you will find these nested OSS rules:\n\n```ts\nfield {\n     type=java.lang.String {\n        @trait=longtext {\n           after:zBottom;\n           editable { component:TextAreaComponent;\n             bindings:{cols:60; rows:10} }\n           ....\n       }\n```\n\nWe\'ll cover the OSS syntax in more details in a different tutorial, but this is one of the rules:\n\n```ts\n  If selectors [field=any, type=String,\n                trait=longtext, editable=true]\n      match the current context values,\n  then apply the properties\n      [component:TextAreaComponent]\n```\n\n\n### Application Rules\n\nSince we have already `User.oss` in the `app/rules` directory we are going to add following\n\n```ts\n       field=age  editable=false {\n          component:AgeRatingComponent;\n          bindings: {\n            value:$value;\n          }\n       }\n```\n\nThe `AgeRatingComponent` might look like this\n\n\n```ts\n  import {Component, Input, OnInit} from \'@angular/core\';\n  import {BaseComponent, Environment} from \'@ngx-metaui/rules\';\n  \n  \n  @Component({\n    selector: \'app-age-rating\',\n    template: `\n      <span class="w-string-field">\n        {{rating}}\n      </span>\n    `\n  })\n  export class AgeRatingComponent extends BaseComponent implements OnInit {\n  \n    @Input()\n    value: any;\n  \n    rating: string;\n  \n    constructor(protected environment: Environment) {\n      super(environment);\n    }\n  \n    ngOnInit(): void {\n      this.rating = (!this.value) ? \'N/A\' : ((this.value && this.value <= 20) ? \'Young\' : \'Good\');\n    }\n  }\n```\n\nAnd dont forget to add this into your module `declarations` as well as `entryComponents` since all is assembled \nprogrammatically\n\n```ts\n  @NgModule({\n    declarations: [\n      AppComponent,\n      UserDetailComponent,\n      AgeRatingComponent\n    ],\n    imports: [\n      BrowserModule,\n      BrowserAnimationsModule,\n      MetaUIRulesModule.forRoot({})\n    ],\n    entryComponents: [AgeRatingComponent],\n    providers: [],\n    bootstrap: [AppComponent]\n})\n\n```\n\nTo help the introspection when MetaUI tries to instantiate `AgeRatingComponent`the type must be known. For this\nwe are going to add export into `user-rules.oss`\n\n\n```ts\n/**\n * Export generated TS files from ./ts directory\n */\n\nexport * from \'./ts/DummyOSS\';\n\n/** Auto generated  export */\nexport * from \'./ts/UserOSS\';\n\nexport * from \'../age-rating/user-detail.component\';\n```\n\n\n\nRecompile oss, serve and let\'s change age from 20 to 30\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/metaui-age-edit.png "Add age 30")\n\nand in read-only mode the value renders as _Good_\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/metaui-age-view.png "Custom component for age field")\n\n\nAnd with that, we just overrode the default component property. To see how MetaUI determine how \nproperties from multiple rules are applied, we need to understand how rules are loaded and ranked...\n\n\n### Rule Loading\n\nOn application initialization:\n\n* Built-in `WidgetsRules.oss` rules are loaded. Build-in rules are already precompiled and are part of the _@ngx-metaui/rules_\n* If global application rule exists the `Application.oss` then its loaded  and there can only be one for the entire application.  \n* On first reference to class name in the MetaUI context:\n  * Introspection rules are created and they are loaded from `app/rules/[EntityNamne].oss`\n  \nTo load rules the `RuleLoaderService` is used.  \n  \n\n\n### Rule Ranking\n\n* Matching rules are applied in rank order to build the property map.\n* Rules from system (default rules) have lowest rank, then introspection rules, then application `.oss` rules.\n* Rank is (roughly) the order of appearance in the .oss file (later == higher rank)\n* When multiple rules update the same property, type and key-specific merge rules are applied:\n  * Maps and trait lists are merged\n  * visible, editable, and valid expressions are chained with AND semantics (except if override value is used - `e.g. visible=true!`)\n  * Other values are overridden\n  \n\n### Visibility\n\nLet\'s continue by adding some advanced rules. We want to hide the description field when we are not editing and \nisAngularDeveloper is false with the visibility property\n\n\n```ts\nfield=description {\n     trait:longtext;\n\n     editing=false {\n        visible: ${object.isAngularDeveloper};\n     }\n}\n```\n\nwhich creates this rule:    \n    \n```ts\nIf selectors [class=User, field=description, editing=false]\n    match the current context values,\nthen apply the properties\n    [visible:${object.isAngularDeveloper}]\n```    \n\nExpressions are wrapped in `${\x85}` and when used in property value, the "this" is the Context object - key\npaths reference assignments in context\n\n\n**The context also has special keys for the following:**\n\n* **object**: The current object instance set on the context by the object context key\n* **value**: The field value from evaluating the current field on the current object in the context\n* **properties**: The current property map access as `properties.get(\'<property name>\')`\n\n\n### Validation\n\nNext we add a validation on the `created` field to ensure that it\'s not a future with the `Validation` condition:\n\n\n```ts\n   field=created {\n      valid:${ object.isValidCreateDate() ? true : "The date cannot be in the future" };\n   }\n```\n\n\nand let\'s add our validation method to domain object `user.ts`:\n\n```typescript\n  isValidCreateDate(): boolean {\n    const dateNow = new Date();\n    return (this.created && this.created < dateNow);\n  }\n```\n\nwhich creates this rule:\n\n```ts\n  If selectors [class=user, field=created]\n      match the current context values,\n  then apply the properties\n      [valid:${object.isValidCreateDate()}]\n```\n\n\nWhen you select future date our custom error message appears\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/validity-created.png "Validate for future date")\n\n\n\n\n\n### Editibility\n\nLet\'s add a rule to prevent the editing the `name` field if the value `isAngularDeveloper` is  not true. \n\n```ts\n     field=name {\n         label:"Full name";\n         trait:required;\n         editable: ${object.isAngularDeveloper};\n     }\n```\n\nwhich creates this rule:\n\n```ts\nIf selectors [class=User, field=name]\n    match the current context values,\nthen apply the properties\n    [editable:${object.isAngularDeveloper}]\n```\n\nSelect _create_ operation and uncheck `isAngularDeveloper` and we see that it the `name` (Full name) is not editable.\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/editable.png "Editable if Angular developer")\n\n\n### Actions\n\nAction is the way how to add some logic into your MetaUI. For example:\n\n* Show a message dialog\n* Trigger routing\n* Or run some typescript/javascript code\n\nLet\'s add an action on the `User.oss` that shows only in editing mode and  when clicked it opens an alert \nwith the `object.name`:\n\n```ts\n  class {   \n    @action=Save  {\n         label: "Save";\n         actionResults:${ alert("Record saved : " + object.name) };\n         visible: ${properties.get("editing")};\n         buttonStyle:info;\n    }\n  }\n\n```\n\nTo be able to see the action let\'s change our `layout` binding to the `InspectWithActions` inside our\n`user-detail.component.html`, so it could\nlook like this:\n\n```html\n  <m-context [object]="object" [operation]="operation" layout="InspectWithActions">\n    <m-include-component></m-include-component>\n  </m-context>\n```\n\nYou can define different variety of layouts but more about this in the next section.\n\nwhich creates this rule:\n\n```ts\nIf selectors [class=User declare=action]\n    match the current context values,\nthen apply the properties\n    [action:Save]\n\nIf selectors [class=User, action=Save]\n    match the current context values,\nthen apply the properties\n   [actionResults:${\n           /*\n              - Run JS code that shows alert\n              - Use an object to access a name              \n           */\n           }\n       ]\n\n```\n\nWhen in editing mode the actions appears under action button placeholder.\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/action-save-1.png "Action Save shows in editing mode")\n     \n\nWhen clicked our message appears in alert dialog:\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/action-save-2.png "Action Save shows in editing mode")\n\nOther way to insert an `Action` we don\'t necessary need to change the layout we can keep the existing `Inspect` layout\nand use other `m-context` element and render actions like this:\n\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/action-links.png "Custom links with new m-context element")\n\n\nLet\'s extend our rules to:\n\n\n```ts\n/*\n  Sample definition for operations edit and create\n\n*/\n class= User {\n   operation=edit {\n      zNone => *;\n      zLeft  => name => description => age;\n   }\n\n  operation=create {\n      zNone => *;\n      zLeft => name => description => created => isAngularDeveloper;\n   }\n\n   @action=Save  {\n        label: "Save";\n        actionResults:${ alert("Record saved !") };\n        visible: ${properties.get("editing")};\n        buttonStyle:info;\n   }\n\n   @action=Discard  {\n         label: "Discard Changes";\n         actionResults:${ alert("All cleared !") };\n         visible: ${properties.get("editing")};\n         buttonStyle:info;\n   }\n}\n```\n\nWe just defined 2 actions on the class user and we can insert them to the page this \nlike this:\n\n```html\n  <span style="float: right">\n    Actions: [\n    <m-context [object]="object"  layout="Links">\n      <m-include-component></m-include-component>\n    </m-context>\n  ]\n\n  </span>\n\n\n  <m-context [object]="object" [operation]="operation" layout="Inspect">\n    <m-include-component></m-include-component>\n  </m-context>\n```\n\n\nWhen discard is clicked:\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/action-links-clicked.png "Custom links with new m-context element")\n\n### Layouts\n\nSo far we discussed how domain objects are rendered, we covered some advanced topics like conditions and \nactions and all this is nothing without layouts. \n\nLayouts are a like containers in MetaUI and they form high level structure in which you place your content.\nEven our form from above is backed up by layout:\n\n```ts\nclass layout=Inspect { \n  trait:Form; \n  label:${UIMeta.beautifyClassName(values.class)}; \n}\n\n@trait=Form { visible:true; component:MetaFormComponent }\n```\n\nIn MetaUI we have two types of containers:\n* module\n* layout\n\n`Module` is just another container that can use multiple layouts to assemble actual page and it used\nto generate top level navigation menu where each menu have its own content\n\n\nLet\'s define 3 tabs:\n \n```ts\n@module=Home {\n    label:"My Home";\n    pageTitle:"You are now on Homepage";\n\n    @layout=Today {\n       after:zTop;\n       label: "Sales Graph";\n       component:SalesGraphComponent;\n    }\n\n    @layout=Sport {\n       after:Today;\n       label: "Sport today!";\n       component:StringComponent;\n       bindings:{value:" ...... " }\n    }\n\n\n     @layout=Tech {\n           after:Sport;\n           label: "Tech News";\n           component:StringComponent;\n           bindings:{value:" ...... " }\n     }\n\n     @layout=MessageBoard {\n        after:zBottom;\n        label: "Message Board";\n        component:StringComponent;\n        portletWidth:large\n        bindings:{value:" ...... " }\n     }\n\n}\n\n\n\n@module=Products {\n    pageTitle:"You are now on Products";\n    homePage:ProductContentComponent;\n}\n\n\n@module=Sources {\n    label:"Sources for Module";\n    homePage:SourcesComponent;\n\n}\n```\n\n\nModule is defined like this:\n\n```ts\nmodule {\n    homePage:MetaHomePageComponent;\n    component:MetaDashboardLayoutComponent;\n    layout { visible:true }   \n}\n```\n\nEvery module is rendered on top of the `component` property (in this case `MetaDashboardLayoutComponent`) \nand uses `homePage`to render given content. In `@module=Home` we defined 4 layouts and distributed\nthem to different zones which are implemented by `MetaDashboardLayoutComponent`.\nOther tabs overrode `homePage` and added regular angular component.\n\nLayouts can in turn contain other layouts or object layouts and action layouts. Like our example from above where\nchanged layout binding to `InspectWithActions` because we needed to have a container that can hold and render actions:\n\n```ts\nlayout=InspectWithActions {\n    trait:Stack;\n    @layout=Actions#ActionMenu;\n    @layout=Inspect#Form;\n}\n```\n\nIn above build-in rule  we defined a layout `InspectWithActions` with `trait` Stack, which adds additional properties such `component`\nthat knows how to render its content in actual _stack_. And we have two named `@layout` where one creates a container \nfor actions and another renders a Form.\n\nSimilar way you can construct any kinds of layouts. Here is an example from different context. Let\'s create a generic\nlayout for `Invoice` class where we want to have expandable sections and each section will have its own content.\n\n\n![alt text](https://raw.githubusercontent.com/ngx-meta/rules/master/docs/meta/section-expanded.png "Custom links with new m-context element")\n\n\nall defined with the rule:\n\n```ts\nlayout=InvoicePage#Sections {\n    @layout=Header#Form {\n        zonePath:Header;\n        title:"Label for header section";\n        description:$object.itemDescription;\n        opened:false;\n    }\n\n    @layout=Participant {\n        title:"Label for Participant section";\n        visible:true;\n        canEdit:true;\n        component:Section2Component;\n        editing {\n            bindings:{\n                oper:\'editx\';\n            }\n        }\n        editing=false {\n            bindings:{\n                oper:\'vieaaa\';\n            }\n        }\n    }\n\n     @layout=Lines {\n        title:"Label for Line Item section";\n        visible:true;\n        canEdit:true;\n        editMode:"external";\n        actionIcon:"icon-positive";\n        component:Section3Component;\n        bindings:{\n            oper:${properties.get("operation")}\n        }\n    }\n    @layout=Footer#Form {\n        title:"Label for footer section";\n        zonePath:Footer;\n    }\n}\n```\n\n\nwith html code like this:\n\n```html\n  <m-context [object]="myRequest" operation="view" layout="InvoicePage"\n                   (onAction)="onActionHandler($event)">\n        <m-include-component></m-include-component>\n   </m-context>\n```\n\nFields are "zoned" by setting their predecessor with a dotted path (e.g. "header.zRight") that \nis establish as the "zonePath" for the nested form in the above ` @layout=Header#Form`\n\nThe application rule to render actual _Invoice_ could look like this:\n\n```\nclass=Invoice {\n    layout {\n        trait:labelsOnTop;\n    }\n    Header.zLeft => uniqueName => itemPrice;\n    Header.zRight => supplier => requestor;\n    Footer.zBottom => itemDescription;\n}\n```\n\n\n### Other Areas to Explore\n\nSo you\'ve seen how `MetaUI` works with domain objects to generate various user interfaces derived from rules. The next steps could be \nto give it a chance and try it out and also look at the following:\n\n* [Build-in rules][2]: Default rules where you can learn various oss constructions.\n* [MetaContext][3]: Angular component `m-context` responsible for setting context and communicating with the rule engine.\n* [MetaIncludeComponent][4]: Key component for reading final evaluated properties and rendering programatically UI.\n* [Meta][5]: Base class rule engine implementation.  \n* [OSS Grammar Tutorial][6]: Introduction to oss syntax  \n\n\n[1]: /getting-started\n[2]: https://github.com/ngx-meta/rules/tree/master/libs/rules/src/lib/metaui/core/oss\n[3]: https://github.com/ngx-meta/rules/blob/master/libs/rules/src/lib/metaui/core/meta-context/meta-context.component.ts\n[4]: https://github.com/ngx-meta/rules/blob/master/libs/rules/src/lib/metaui/layout/meta-include.directive.ts\n[5]: https://github.com/ngx-meta/rules/blob/master/libs/rules/src/lib/metaui/core/meta.ts\n[6]: /oss-syntax\n'}}]);